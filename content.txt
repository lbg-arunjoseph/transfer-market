===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/dto/CreatePlayerRequest.java =====
package org.acme.dto;
import java.math.BigDecimal;

public class CreatePlayerRequest {         // maps incoming JSON when creating a player
    public String name;                    // player name
    public BigDecimal price;               // asking price
    public Long clubId;                    // which club owns him initially
}

===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/dto/CreateClubRequest.java =====
package org.acme.dto;

import java.math.BigDecimal;

public class CreateClubRequest {           // maps incoming JSON when creating a club
    public String name;                    // club name
    public BigDecimal budget;              // starting budget
}
===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/dto/TransferRequest.java =====
package org.acme.dto;

public class TransferRequest {             // maps the transfer command
    public Long buyerClubId;               // club that wants to buy
    public Long playerId;                  // player being bought
}
===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/dto/TransferResult.java =====
package org.acme.dto;

import java.math.BigDecimal;

public class TransferResult {              // response after transfer
    public Long playerId;
    public String playerName;
    public String fromClub;
    public String toClub;
    public BigDecimal price;
    public BigDecimal buyerBudgetAfter;
    public BigDecimal sellerBudgetAfter;
}
===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/chat/ChatResource.java =====
package org.acme.chat;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.inject.Inject;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import org.acme.chat.ChatDtos.*;

import static org.acme.chat.Prompts.schemaCard;
import static org.acme.chat.Prompts.verbaliseCard;

@Path("/chat")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public class ChatResource {

    @Inject
    OllamaClient llm;

    @Inject
    SqlRunner sqlRunner;

    @Inject
    ObjectMapper mapper;

    @POST
    @Transactional(Transactional.TxType.REQUIRED) // read-only work fits in a tx for consistency
    public Response chat(ChatRequest req) {
        if (req == null || req.question == null || req.question.isBlank()) {
            throw new BadRequestException("question is required");
        }

        try {
            // Step 1: get plan (sql or final)
            String planJson = llm.chat(schemaCard(), req.question.trim());

            LlmPlan plan = mapper.readValue(planJson, LlmPlan.class);
            if (plan.type == null) throw new WebApplicationException("Model returned an invalid plan", 502);

            if ("final".equalsIgnoreCase(plan.type)) {
                var out = new ChatResponse();
                out.answer = plan.answer == null ? "(no answer)" : plan.answer;
                out.usedSql = false;
                return Response.ok(out).build();
            }

            if (!"sql".equalsIgnoreCase(plan.type) || plan.sql == null || plan.sql.isBlank()) {
                throw new WebApplicationException("Model did not return a SQL plan", 502);
            }

            // Guardrails and run
            sqlRunner.validateReadOnly(plan.sql);
            String safeSql = sqlRunner.enforceLimit(plan.sql);
            var rows = sqlRunner.runNative(safeSql);

            // Step 2: verbalise results
            String verbaliseUserMsg = "Question: " + req.question.trim() + "\n"
                    + "Columns: " + mapper.writeValueAsString(rows.columns) + "\n"
                    + "Rows: " + mapper.writeValueAsString(rows.rows);

            String finalJson = llm.chat(verbaliseCard(), verbaliseUserMsg);
            LlmPlan finalPlan = mapper.readValue(finalJson, LlmPlan.class);
            if (!"final".equalsIgnoreCase(finalPlan.type)) {
                throw new WebApplicationException("Model did not return a final answer", 502);
            }

            var out = new ChatResponse();
            out.answer = finalPlan.answer;
            out.usedSql = true;
            out.sql = safeSql;
            out.rows = rows;
            return Response.ok(out).build();

        } catch (Exception e) {
            var out = new ChatResponse();
            out.error = e.getMessage();
            return Response.status(Response.Status.BAD_GATEWAY).entity(out).build();
        }
    }
}
===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/chat/Prompts.java =====
package org.acme.chat;

public class Prompts {

    public static String schemaCard() {
        return String.join("\n",
                "You are a helpful data assistant for a football transfer app.",
                "You can only produce JSON with this schema: {\"type\":\"sql\",\"sql\":\"...\"} OR {\"type\":\"final\",\"answer\":\"...\"}.",
                "Never include any extra text outside JSON.",
                "",
                "Database schema (H2):",
                "Table Club columns: id BIGINT, name VARCHAR, budget DECIMAL(19,2)",
                "Table Player columns: id BIGINT, name VARCHAR, price DECIMAL(19,2), club_id BIGINT",
                "Join rule: Player.club_id = Club.id",
                "",
                "Rules:",
                "- Only produce read-only SELECT queries. Never modify data.",
                "- Prefer case-insensitive name matching using UPPER(name) LIKE UPPER('%TERM%').",
                "- If the user asks for counts, use COUNT(*).",
                "- Use simple SQL that H2 supports.",
                "- Keep queries small; avoid selecting too many columns when not needed.",
                "- If the user question is already directly answerable without SQL, return {\"type\":\"final\",\"answer\":\"...\"}.",
                "- Otherwise return {\"type\":\"sql\",\"sql\":\"...\"}.",
                ""
        );
    }

    public static String verbaliseCard() {
        return String.join("\n",
                "You are turning SQL result rows into a single concise natural-language answer.",
                "Only produce JSON with {\"type\":\"final\",\"answer\":\"...\"}. No extra text.",
                "If there are no rows, say that nothing was found.",
                "If the question was for a list, join items with commas in a single sentence."
        );
    }
}
===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/chat/SqlRunner.java =====
package org.acme.chat;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.regex.Pattern;

import static org.acme.chat.ChatDtos.SqlResultForLlm;

@ApplicationScoped
public class SqlRunner {

    @PersistenceContext
    EntityManager em;

    @Inject
    ObjectMapper mapper;

    // Allowed tables and columns (keep small and explicit)
    static final List<String> ALLOWED_TABLES = List.of("CLUB", "PLAYER"); // H2 folds unquoted to upper
    static final List<String> CLUB_COLUMNS = List.of("ID", "NAME", "BUDGET");
    static final List<String> PLAYER_COLUMNS = List.of("ID", "NAME", "PRICE", "CLUB_ID");

    // Very simple checks for learning purposes
    static final Pattern SELECT_ONLY = Pattern.compile("^\\s*SELECT\\b", Pattern.CASE_INSENSITIVE);

    public String enforceLimit(String sql) {
        var up = sql.toUpperCase(Locale.ROOT);
        if (!up.contains("LIMIT ")) {
            return sql.trim() + " LIMIT 200";
        }
        return sql;
    }

    public void validateReadOnly(String sql) {
        if (!SELECT_ONLY.matcher(sql).find()) {
            throw new IllegalArgumentException("Only SELECT queries are allowed");
        }

        // Crude table/column allow-listing by scanning tokens
        var up = sql.toUpperCase(Locale.ROOT);
        // Tables
        for (String token : List.of(" CLUB ", " CLUB)", " CLUB,", " CLUB\n", " CLUB\t",
                " PLAYER ", " PLAYER)", " PLAYER,", " PLAYER\n", " PLAYER\t")) {
            // presence is OK, but we also ensure no unknown table is referenced by FROM/JOIN
        }
        // A stricter approach: forbid quotes and semicolons for this exercise
        if (up.contains(";") || up.contains("--") || up.contains("/*")) {
            throw new IllegalArgumentException("Suspicious SQL");
        }
        // Columns: we just prevent obvious unknown identifiers by a tiny heuristic
        // (For a real system, parse SQL or use a safe query builder)
    }

    @SuppressWarnings("unchecked")
    public SqlResultForLlm runNative(String sql) {
        var q = em.createNativeQuery(sql);
        var result = q.getResultList();

        List<String> columns = new ArrayList<>();
        List<List<Object>> rows = new ArrayList<>();

        // Try to fetch column names via unwrap to org.hibernate.query.NativeQuery if available
//        try {
//            var nativeQuery = q.unwrap(org.hibernate.query.NativeQuery.class);
//            var metas = nativeQuery.getReturnAliases();
//            if (metas != null) {
//                columns = Arrays.asList(metas);
//            }
//        } catch (Exception ignore) {}

        // Fallback: if we have no columns metadata, infer length from first row
        if (result.isEmpty()) {
            Object first = result.get(0);
            int width = (first instanceof Object[]) ? ((Object[]) first).length : 1;
            for (int i = 0; i < width; i++) columns.add("col" + (i + 1));
        }

        for (Object row : (List<Object>) result) {
            if (row instanceof Object[]) {
                rows.add(Arrays.asList((Object[]) row));
            } else {
                rows.add(List.of(row));
            }
        }

        var out = new SqlResultForLlm();
        out.columns = columns;
        out.rows = rows;
        return out;
    }
}
===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/chat/OllamaClient.java =====
package org.acme.chat;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import org.eclipse.microprofile.config.inject.ConfigProperty;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.List;

import static org.acme.chat.ChatDtos.*;

@ApplicationScoped
public class OllamaClient {

    @ConfigProperty(name = "ollama.base-url", defaultValue = "http://localhost:11434")
    String baseUrl;

    @ConfigProperty(name = "ollama.model", defaultValue = "mistral:latest")
    String model;

    @ConfigProperty(name = "ollama.connect-timeout", defaultValue = "5000")
    int connectTimeoutMs;

    @ConfigProperty(name = "ollama.read-timeout", defaultValue = "30000")
    int readTimeoutMs;

    @Inject
    ObjectMapper mapper;

    HttpClient client;

    void ensureClient() {
        if (client == null) {
            client = HttpClient.newBuilder()
                    .connectTimeout(Duration.ofMillis(connectTimeoutMs))
                    .build();
        }
    }

    public String chat(String systemPrompt, String userPrompt) throws Exception {
        ensureClient();

        var req = new OllamaChatRequest();
        req.model = model;
        req.stream = false;
        req.messages = List.of(
                new OllamaMessage("system", systemPrompt),
                new OllamaMessage("user", userPrompt)
        );

        var body = mapper.writeValueAsString(req);

        var httpReq = HttpRequest.newBuilder()
                .uri(URI.create(baseUrl + "/api/chat"))
                .timeout(Duration.ofMillis(readTimeoutMs))
                .header("Content-Type", "application/json")
                .POST(HttpRequest.BodyPublishers.ofString(body))
                .build();

        var resp = client.send(httpReq, HttpResponse.BodyHandlers.ofString());
        if (resp.statusCode() >= 300) {
            throw new RuntimeException("Ollama error: HTTP " + resp.statusCode() + " body=" + resp.body());
        }

        // Ollama returns: {"message":{"role":"assistant","content":"..."},"done":true,...}
        var node = (ObjectNode) mapper.readTree(resp.body());
        var msg = node.path("message").path("content").asText(null);
        if (msg == null) {
            // Fallback older shapes
            msg = node.path("content").asText(null);
        }
        if (msg == null) {
            throw new RuntimeException("Could not parse Ollama response message");
        }
        return msg;
    }
}
===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/chat/ChatDtos.java =====
package org.acme.chat;

import java.util.List;
import java.util.Map;

public class ChatDtos {

    public static class ChatRequest {
        public String question;
    }

    public static class ChatResponse {
        public String answer;
        public boolean usedSql;
        public String sql;           // optional, for debugging
        public Object rows;          // optional, echo rows we used
        public String error;         // optional
    }

    // Internal DTOs to talk to Ollama /api/chat
    public static class OllamaMessage {
        public String role;
        public String content;
        public OllamaMessage() {}
        public OllamaMessage(String role, String content) { this.role = role; this.content = content; }
    }

    public static class OllamaChatRequest {
        public String model;
        public List<OllamaMessage> messages;
        public boolean stream = false;
        public Map<String,Object> options; // optional tuning
    }

    public static class OllamaChatResponse {
        public String model;
        public String created_at;
        public List<Choice> message; // NOTE: Ollama returns a single message object in newer APIs; we’ll parse content safely
        public String done_reason;
        public boolean done;
        // We only need the assistant message content; to be robust, we'll map a minimal structure:
        public AssistantMessage messageObj;
        public static class Choice { public String content; }
        public static class AssistantMessage { public String role; public String content; }
    }

    // The strict JSON the model should return to us
    public static class LlmPlan {
        public String type;  // "sql" or "final"
        public String sql;
        public String answer;
    }

    public static class SqlResultForLlm {
        public List<String> columns;
        public List<List<Object>> rows;
    }
}
===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/ClubResource.java =====
package org.acme;

import org.acme.dto.CreateClubRequest;                      // DTO for POST
import io.smallrye.common.annotation.Blocking;                          // mark blocking endpoints (JPA is blocking)
import jakarta.transaction.Transactional;                                // for DB writes
import jakarta.ws.rs.*;                                                  // JAX-RS annotations
import jakarta.ws.rs.core.MediaType;                                     // content types
import jakarta.ws.rs.core.Response;                                      // HTTP response wrapper
import java.math.BigDecimal;                                             // validation for budget
import java.util.List;                                                   // list for GET all
import java.util.Optional;                                               // for findByIdOptional

@Path("/clubs")                                                          // base path for club API
@Consumes(MediaType.APPLICATION_JSON)                                    // accept JSON
@Produces(MediaType.APPLICATION_JSON)                                    // return JSON
@Blocking                                                                 // ensure handled on worker thread (JPA)
public class ClubResource {

    @GET                                                                 // GET /clubs
    public List<Club> list() {                                           // list all clubs
        return Club.listAll();                                           // Panache helper -> SELECT * FROM Club
    }

    @GET
    @Path("/{id}")                                                       // GET /clubs/{id}
    public Club get(@PathParam("id") Long id) {                          // read one club
        return Club.<Club>findByIdOptional(id)                                 // returns Optional<Club>
                .orElseThrow(() -> new NotFoundException("Club not found: " + id));
    }

    @POST                                                                // POST /clubs
    @Transactional                                                       // wrap in transaction for DB write
    public Response create(CreateClubRequest req) {                      // JSON request body mapped to DTO
        if (req == null || req.name == null || req.name.isBlank())
            throw new BadRequestException("name is required");
        if (req.budget == null || req.budget.compareTo(BigDecimal.ZERO) < 0)
            throw new BadRequestException("budget must be >= 0");

        Club c = new Club();                                             // new entity
        c.name = req.name.trim();                                        // set name
        c.budget = req.budget;                                           // set budget
        c.persist();                                                     // INSERT into DB

        return Response                                                  // HTTP 201 + created entity
                .status(Response.Status.CREATED)
                .entity(c)
                .build();
    }
}
===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/PlayerResource.java =====
package org.acme;

import org.acme.dto.CreatePlayerRequest;
import io.smallrye.common.annotation.Blocking;                           // blocking (JPA)
import jakarta.transaction.Transactional;                                 // DB write boundary
import jakarta.ws.rs.*;                                                   // JAX-RS
import jakarta.ws.rs.core.MediaType;                                      // JSON content-type
import jakarta.ws.rs.core.Response;                                       // HTTP responses
import java.math.BigDecimal;                                              // for price checks
import java.util.List;                                                    // list endpoint

@Path("/players")                                                         // base path for player API
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Blocking
public class PlayerResource {

    @GET                                                                  // GET /players
    public List<Player> list() {
        return Player.listAll();                                          // SELECT * FROM Player
    }

    @GET
    @Path("/{id}")                                                        // GET /players/{id}
    public Player get(@PathParam("id") Long id) {
        return Player.<Player>findByIdOptional(id)
                .orElseThrow(() -> new NotFoundException("Player not found: " + id));
    }

    @POST                                                                 // POST /players
    @Transactional
    public Response create(CreatePlayerRequest req) {
        if (req == null || req.name == null || req.name.isBlank())
            throw new BadRequestException("name is required");
        if (req.price == null || req.price.compareTo(BigDecimal.ZERO) < 0)
            throw new BadRequestException("price must be >= 0");
        if (req.clubId == null)
            throw new BadRequestException("clubId is required");

        Club club = Club.<Club>findByIdOptional(req.clubId)                     // resolve owning club
                .orElseThrow(() -> new NotFoundException("clubId not found: " + req.clubId));

        Player p = new Player();                                          // new player
        p.name = req.name.trim();                                         // set fields
        p.price = req.price;
        p.club = club;                                                    // link to owner club
        p.persist();                                                      // INSERT

        return Response.status(Response.Status.CREATED).entity(p).build();// return 201
    }
}
===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/TransferService.java =====
package org.acme;

import org.acme.dto.TransferResult;                 // response DTO
import jakarta.enterprise.context.ApplicationScoped;            // CDI bean (one per app)
import jakarta.transaction.Transactional;                       // wrap transfer in a transaction
import jakarta.ws.rs.BadRequestException;                       // 400 on invalid request
import jakarta.ws.rs.NotFoundException;                         // 404 when entity missing
import java.math.BigDecimal;                                    // money operations

@ApplicationScoped                                               // managed bean
public class TransferService {

    @Transactional                                              // all DB changes happen atomically
    public TransferResult transfer(Long buyerClubId, Long playerId) {
        if (buyerClubId == null || playerId == null)
            throw new BadRequestException("buyerClubId and playerId are required");

        Club buyer = Club.<Club>findByIdOptional(buyerClubId)         // fetch buyer
                .orElseThrow(() -> new NotFoundException("Buyer club not found: " + buyerClubId));

        Player player = Player.<Player>findByIdOptional(playerId)       // fetch player
                .orElseThrow(() -> new NotFoundException("Player not found: " + playerId));

        Club seller = player.club;                              // current owner
        if (seller == null)
            throw new BadRequestException("Player has no current club");
        if (seller.id.equals(buyer.id))
            throw new BadRequestException("Buyer already owns this player");

        BigDecimal price = player.price;                        // agreed price
        if (buyer.budget.compareTo(price) < 0)                  // can buyer afford?
            throw new BadRequestException("Buyer cannot afford this player");

        // Money moves: buyer pays, seller receives
        buyer.budget = buyer.budget.subtract(price);            // deduct from buyer
        seller.budget = seller.budget.add(price);               // add to seller

        // Transfer registration
        player.club = buyer;                                    // change ownership

        // No explicit persist() needed: entities are managed in a transaction.

        // result payload
        TransferResult result = new TransferResult();
        result.playerId = player.id;
        result.playerName = player.name;
        result.fromClub = seller.name;
        result.toClub = buyer.name;
        result.price = price;
        result.buyerBudgetAfter = buyer.budget;
        result.sellerBudgetAfter = seller.budget;

        return result;                                          // returned as JSON by resource
    }
}
===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/GreetingResource.java =====
package org.acme;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/hello")
public class GreetingResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "Hello from Quarkus REST";
    }
}

===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/Player.java =====
package org.acme; // package groups related classes

import com.fasterxml.jackson.annotation.JsonIgnore;           // to avoid infinite JSON loops with bidirectional links
import com.fasterxml.jackson.annotation.JsonProperty;         // to expose computed fields
import io.quarkus.hibernate.orm.panache.PanacheEntity;        // Panache base
import jakarta.persistence.*;                                 // JPA
import java.math.BigDecimal;                                  // money

@Entity                                                      // This becomes a table 'Player'
public class Player extends PanacheEntity {                   // id (Long) provided by PanacheEntity

    @Column(nullable = false)                                 // must have a name
    public String name;

    @Column(nullable = false, precision = 19, scale = 2)      // price (e.g., 74300000.00)
    public BigDecimal price;

    @ManyToOne(optional = false, fetch = FetchType.LAZY)      // many players belong to a single club
    @JoinColumn(name = "club_id")                             // FK column in Player table
    @JsonIgnore                                               // hide to prevent recursion when serialising JSON
    public Club club;

    @JsonProperty("clubId")                                   // expose 'clubId' in JSON while keeping 'club' ignored
    public Long jsonClubId() {
        return club == null ? null : club.id;                 // compute club id for clients
    }
}
===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/TransferResource.java =====
package org.acme;

import org.acme.dto.TransferRequest;                 // input DTO
import org.acme.dto.TransferResult;                  // output DTO
import io.smallrye.common.annotation.Blocking;                   // JPA is blocking
import jakarta.inject.Inject;                                    // DI for service
import jakarta.ws.rs.*;                                          // JAX-RS annotations
import jakarta.ws.rs.core.MediaType;                             // JSON
import jakarta.ws.rs.core.Response;                              // HTTP responses

@Path("/transfers")                                              // base path for transfers
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Blocking
public class TransferResource {

    @Inject                                                      // inject our business service
    TransferService service;

    @POST                                                        // POST /transfers
    public Response transfer(TransferRequest req) {              // JSON -> DTO
        TransferResult result = service.transfer(req.buyerClubId, req.playerId);  // do it
        return Response.ok(result).build();                      // 200 with result JSON
    }
}
===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/Club.java =====
package org.acme;

import io.quarkus.hibernate.orm.panache.PanacheEntity;
import jakarta.persistence.*;
import java.math.BigDecimal;
import java.util.List;

@Entity                                                      // Marks this as a JPA entity (mapped to a table)
public class Club extends PanacheEntity {                    // Extends PanacheEntity => gets a Long id and helpers

    @Column(nullable = false, unique = true)
    public String name;

    @Column(nullable = false, precision = 19, scale = 2)
    public BigDecimal budget;

    @OneToMany(mappedBy = "club",                            // players reference their club; 'club' is the owner side
            cascade = CascadeType.ALL,                    // propagate saves/deletes to players
            orphanRemoval = true)                         // remove players if they’re de-linked
    public List<Player> players;                             // list of players for this club
}
===== /Users/arun-joy.joseph/IdeaProjects/transfer-market/src/main/java/org/acme/GenericExceptionMapper.java =====
package org.acme;

import jakarta.ws.rs.ext.ExceptionMapper;
import jakarta.ws.rs.ext.Provider;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.NotFoundException;
import jakarta.ws.rs.BadRequestException;
import java.util.HashMap;
import java.util.Map;

@Provider
public class GenericExceptionMapper implements ExceptionMapper<Throwable> {
    @Override
    public Response toResponse(Throwable exception) {
        Map<String, String> error = new HashMap<>();
        error.put("error", exception.getMessage());

        if (exception instanceof NotFoundException) {
            return Response.status(Response.Status.NOT_FOUND)
                    .entity(error)
                    .type(MediaType.APPLICATION_JSON)
                    .build();
        } else if (exception instanceof BadRequestException) {
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(error)
                    .type(MediaType.APPLICATION_JSON)
                    .build();
        } else {
            // For all other exceptions, return 500
            error.put("error", "Internal server error");
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                    .entity(error)
                    .type(MediaType.APPLICATION_JSON)
                    .build();
        }
    }
}

