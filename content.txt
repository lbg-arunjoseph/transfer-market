=====org/acme/dto/CreatePlayerRequest.java=====


package org.acme.dto;
import java.math.BigDecimal;

public class CreatePlayerRequest {
    public String name;
    public BigDecimal price;
    public Long clubId;
}


=====org/acme/dto/CreateClubRequest.java=====


package org.acme.dto;

import java.math.BigDecimal;

public class CreateClubRequest {
    public String name;
    public BigDecimal budget;
}

=====org/acme/dto/TransferRequest.java=====


package org.acme.dto;

public class TransferRequest {
    public Long buyerClubId;
    public Long playerId;
}

=====org/acme/dto/TransferResult.java=====


package org.acme.dto;

import java.math.BigDecimal;

public class TransferResult {
    public Long playerId;
    public String playerName;
    public String fromClub;
    public String toClub;
    public BigDecimal price;
    public BigDecimal buyerBudgetAfter;
    public BigDecimal sellerBudgetAfter;
}


=====org/acme/chat/SqlRunner.java=====


package org.acme.chat;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Pattern;

import static org.acme.chat.ChatDtos.SqlResultForLlm;

@ApplicationScoped
public class SqlRunner {

    @PersistenceContext
    EntityManager em;

    @Inject
    ObjectMapper mapper;

    // Allowed tables and columns (keep small and explicit)
    static final List<String> ALLOWED_TABLES = List.of("CLUB", "PLAYER"); // H2 folds unquoted to upper
    static final List<String> CLUB_COLUMNS = List.of("ID", "NAME", "BUDGET");
    static final List<String> PLAYER_COLUMNS = List.of("ID", "NAME", "PRICE", "CLUB_ID");

    // Very simple checks for learning purposes
    static final Pattern SELECT_ONLY = Pattern.compile("^\\s*SELECT\\b", Pattern.CASE_INSENSITIVE);

    public String enforceLimit(String sql) {
        var up = sql.toUpperCase(Locale.ROOT);
        if (!up.contains("LIMIT ")) {
            return sql.trim() + " LIMIT 200";
        }
        return sql;
    }

    public void validateReadOnly(String sql) {
        if (!SELECT_ONLY.matcher(sql).find()) {
            throw new IllegalArgumentException("Only SELECT queries are allowed");
        }

        // Crude table/column allow-listing by scanning tokens
        var up = sql.toUpperCase(Locale.ROOT);
        // Tables
        for (String token : List.of(" CLUB ", " CLUB)", " CLUB,", " CLUB\n", " CLUB\t",
                " PLAYER ", " PLAYER)", " PLAYER,", " PLAYER\n", " PLAYER\t")) {
            // presence is OK, but we also ensure no unknown table is referenced by FROM/JOIN
        }
        // A stricter approach: forbid quotes and semicolons for this exercise
        if (up.contains(";") || up.contains("--") || up.contains("/*")) {
            throw new IllegalArgumentException("Suspicious SQL");
        }
        // Columns: we just prevent obvious unknown identifiers by a tiny heuristic
        // (For a real system, parse SQL or use a safe query builder)
    }

    @SuppressWarnings("unchecked")
    public SqlResultForLlm runNative(String sql) {
        var q = em.createNativeQuery(sql);
        var result = q.getResultList();

        List<String> columns = new ArrayList<>();
        List<List<Object>> rows = new ArrayList<>();

        String up = sql.toUpperCase(Locale.ROOT);
        boolean isClub = up.contains("FROM CLUB");
        boolean isPlayer = up.contains("FROM PLAYER");

        // If result is not empty and first row is Object[], infer columns by count
        if (!result.isEmpty() && result.get(0) instanceof Object[]) {
            int width = ((Object[]) result.get(0)).length;
            if (isClub && width == CLUB_COLUMNS.size()) {
                columns = new ArrayList<>(CLUB_COLUMNS);
            } else if (isPlayer && width == PLAYER_COLUMNS.size()) {
                columns = new ArrayList<>(PLAYER_COLUMNS);
            } else {
                for (int i = 0; i < width; i++) columns.add("col" + (i + 1));
            }
        } else if (!result.isEmpty()) {
            // Single column result
            if (isClub) {
                columns = List.of(CLUB_COLUMNS.get(0));
            } else if (isPlayer) {
                columns = List.of(PLAYER_COLUMNS.get(0));
            } else {
                columns = List.of("col1");
            }
        } else {
            // No results, fallback to table columns if possible
            if (isClub) {
                columns = new ArrayList<>(CLUB_COLUMNS);
            } else if (isPlayer) {
                columns = new ArrayList<>(PLAYER_COLUMNS);
            }
        }

        for (Object row : result) {
            List<Object> rowList = new ArrayList<>();
            if (row instanceof Object[]) {
                Object[] arr = (Object[]) row;
                for (int i = 0; i < columns.size() && i < arr.length; i++) {
                    rowList.add(arr[i]);
                }
            } else if (row instanceof Map) {
                Map<?,?> mapRow = (Map<?,?>) row;
                for (String col : columns) {
                    rowList.add(mapRow.get(col));
                }
            } else {
                // Single column result
                rowList.add(row);
            }
            rows.add(rowList);
        }

        var out = new SqlResultForLlm();
        out.columns = columns;
        out.rows = rows;
        return out;
    }
}


=====org/acme/chat/SqlResource.java=====


package org.acme.chat;

import jakarta.inject.Inject;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import io.smallrye.common.annotation.Blocking;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;

@Path("/sql")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public class SqlResource {

    @Inject
    SqlRunner sqlRunner;

    @POST
    @Blocking // Ensure DB access is on a worker thread
    public Response runSql(Map<String, String> body) {
        String sql = body.get("sql");
        if (sql == null || sql.isBlank()) {
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(Map.of("error", "Missing 'sql' field in request body"))
                    .build();
        }
        try {
            // Validate and enforce limit
            sqlRunner.validateReadOnly(sql);
            String safeSql = sqlRunner.enforceLimit(sql);
            // Run the query
            var result = sqlRunner.runNative(safeSql);
            // Convert columns and rows to a list of maps
            List<Map<String, Object>> rows = new ArrayList<>();
            for (List<Object> row : result.rows) {
                Map<String, Object> rowMap = new java.util.LinkedHashMap<>();
                for (int i = 0; i < result.columns.size(); i++) {
                    rowMap.put(result.columns.get(i), row.get(i));
                }
                rows.add(rowMap);
            }
            return Response.ok(Map.of("rows", rows)).build();
        } catch (IllegalArgumentException e) {
            // For validation errors (e.g., non-SELECT statement)
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(Map.of("error", e.getMessage()))
                    .build();
        } catch (Exception e) {
            // For all other errors
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                    .entity(Map.of("error", e.getMessage()))
                    .build();
        }
    }
}


=====org/acme/ClubResource.java=====


package org.acme;

import org.acme.dto.CreateClubRequest;
import io.smallrye.common.annotation.Blocking;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

@Path("/clubs")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Blocking
public class ClubResource {

    @GET
    public List<Club> list() {
        return Club.listAll();
    }

    @GET
    @Path("/{id}")
    public Club get(@PathParam("id") Long id) {
        return Club.<Club>findByIdOptional(id)
                .orElseThrow(() -> new NotFoundException("Club not found: " + id));
    }

    @POST
    @Transactional
    public Response create(CreateClubRequest req) {
        if (req == null || req.name == null || req.name.isBlank())
            throw new BadRequestException("name is required");
        if (req.budget == null || req.budget.compareTo(BigDecimal.ZERO) < 0)
            throw new BadRequestException("budget must be >= 0");

        Club c = new Club();
        c.name = req.name.trim();
        c.budget = req.budget;
        c.persist();

        return Response
                .status(Response.Status.CREATED)
                .entity(c)
                .build();
    }
}

=====org/acme/PlayerResource.java=====


package org.acme;

import org.acme.dto.CreatePlayerRequest;
import io.smallrye.common.annotation.Blocking;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import java.math.BigDecimal;
import java.util.List;

@Path("/players")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Blocking
public class PlayerResource {

    @GET
    public List<Player> list() {
        return Player.listAll();
    }

    @GET
    @Path("/{id}")
    public Player get(@PathParam("id") Long id) {
        return Player.<Player>findByIdOptional(id)
                .orElseThrow(() -> new NotFoundException("Player not found: " + id));
    }

    @POST
    @Transactional
    public Response create(CreatePlayerRequest req) {
        if (req == null || req.name == null || req.name.isBlank())
            throw new BadRequestException("name is required");
        if (req.price == null || req.price.compareTo(BigDecimal.ZERO) < 0)
            throw new BadRequestException("price must be >= 0");
        if (req.clubId == null)
            throw new BadRequestException("clubId is required");

        Club club = Club.<Club>findByIdOptional(req.clubId)
                .orElseThrow(() -> new NotFoundException("clubId not found: " + req.clubId));

        Player p = new Player();
        p.name = req.name.trim();
        p.price = req.price;
        p.club = club;
        p.persist();

        return Response.status(Response.Status.CREATED).entity(p).build();
    }
}

=====org/acme/TransferService.java=====


package org.acme;

import org.acme.dto.TransferResult;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.BadRequestException;
import jakarta.ws.rs.NotFoundException;
import java.math.BigDecimal;

@ApplicationScoped
public class TransferService {

    @Transactional
    public TransferResult transfer(Long buyerClubId, Long playerId) {
        if (buyerClubId == null || playerId == null)
            throw new BadRequestException("buyerClubId and playerId are required");

        Club buyer = Club.<Club>findByIdOptional(buyerClubId)
                .orElseThrow(() -> new NotFoundException("Buyer club not found: " + buyerClubId));

        Player player = Player.<Player>findByIdOptional(playerId)
                .orElseThrow(() -> new NotFoundException("Player not found: " + playerId));

        Club seller = player.club;
        if (seller == null)
            throw new BadRequestException("Player has no current club");
        if (seller.id.equals(buyer.id))
            throw new BadRequestException("Buyer already owns this player");

        BigDecimal price = player.price;
        if (buyer.budget.compareTo(price) < 0)
            throw new BadRequestException("Buyer cannot afford this player");

        // Money moves: buyer pays, seller receives
        buyer.budget = buyer.budget.subtract(price);
        seller.budget = seller.budget.add(price);

        // Transfer registration
        player.club = buyer;


        // result payload
        TransferResult result = new TransferResult();
        result.playerId = player.id;
        result.playerName = player.name;
        result.fromClub = seller.name;
        result.toClub = buyer.name;
        result.price = price;
        result.buyerBudgetAfter = buyer.budget;
        result.sellerBudgetAfter = seller.budget;

        return result;
    }
}

=====org/acme/GreetingResource.java=====


package org.acme;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/hello")
public class GreetingResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "Hello from Quarkus REST";
    }
}


=====org/acme/Player.java=====


package org.acme;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.quarkus.hibernate.orm.panache.PanacheEntity;
import jakarta.persistence.*;
import java.math.BigDecimal;

@Entity
public class Player extends PanacheEntity {

    @Column(nullable = false)
    public String name;

    @Column(nullable = false, precision = 19, scale = 2)
    public BigDecimal price;

    @ManyToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = "club_id")
    @JsonIgnore
    public Club club;

    @JsonProperty("clubId")
    public Long jsonClubId() {
        return club == null ? null : club.id;
    }
}

=====org/acme/TransferResource.java=====


package org.acme;

import org.acme.dto.TransferRequest;                 // input DTO
import org.acme.dto.TransferResult;                  // output DTO
import io.smallrye.common.annotation.Blocking;                   // JPA is blocking
import jakarta.inject.Inject;                                    // DI for service
import jakarta.ws.rs.*;                                          // JAX-RS annotations
import jakarta.ws.rs.core.MediaType;                             // JSON
import jakarta.ws.rs.core.Response;                              // HTTP responses

@Path("/transfers")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Blocking
public class TransferResource {

    @Inject
    TransferService service;

    @POST
    public Response transfer(TransferRequest req) {
        TransferResult result = service.transfer(req.buyerClubId, req.playerId);
        return Response.ok(result).build();
    }
}

=====org/acme/Club.java=====


package org.acme;

import io.quarkus.hibernate.orm.panache.PanacheEntity;
import jakarta.persistence.*;
import java.math.BigDecimal;
import java.util.List;

@Entity
public class Club extends PanacheEntity {

    @Column(nullable = false, unique = true)
    public String name;

    @Column(nullable = false, precision = 19, scale = 2)
    public BigDecimal budget;

    @OneToMany(mappedBy = "club",
            cascade = CascadeType.ALL,
            orphanRemoval = true)
    public List<Player> players;
}

=====org/acme/GenericExceptionMapper.java=====


package org.acme;

import jakarta.ws.rs.ext.ExceptionMapper;
import jakarta.ws.rs.ext.Provider;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.NotFoundException;
import jakarta.ws.rs.BadRequestException;
import java.util.HashMap;
import java.util.Map;

@Provider
public class GenericExceptionMapper implements ExceptionMapper<Throwable> {
    @Override
    public Response toResponse(Throwable exception) {
        Map<String, String> error = new HashMap<>();
        error.put("error", exception.getMessage());

        if (exception instanceof NotFoundException) {
            return Response.status(Response.Status.NOT_FOUND)
                    .entity(error)
                    .type(MediaType.APPLICATION_JSON)
                    .build();
        } else if (exception instanceof BadRequestException) {
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(error)
                    .type(MediaType.APPLICATION_JSON)
                    .build();
        } else {
            // For all other exceptions, return 500
            error.put("error", "Internal server error");
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                    .entity(error)
                    .type(MediaType.APPLICATION_JSON)
                    .build();
        }
    }
}


