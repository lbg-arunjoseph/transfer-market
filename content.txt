=====org/acme/dto/CreatePlayerRequest.java=====


package org.acme.dto;
import java.math.BigDecimal;

public class CreatePlayerRequest {
    public String name;
    public BigDecimal price;
    public Long clubId;
}


=====org/acme/dto/CreateClubRequest.java=====


package org.acme.dto;

import java.math.BigDecimal;

public class CreateClubRequest {
    public String name;
    public BigDecimal budget;
}

=====org/acme/dto/TransferRequest.java=====


package org.acme.dto;

public class TransferRequest {
    public Long buyerClubId;
    public Long playerId;
}

=====org/acme/dto/TransferResult.java=====


package org.acme.dto;

import java.math.BigDecimal;

public class TransferResult {
    public Long playerId;
    public String playerName;
    public String fromClub;
    public String toClub;
    public BigDecimal price;
    public BigDecimal buyerBudgetAfter;
    public BigDecimal sellerBudgetAfter;
}

=====org/acme/chat/ChatResource.java=====


package org.acme.chat;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.inject.Inject;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import org.acme.chat.ChatDtos.*;

import static org.acme.chat.Prompts.schemaCard;
import static org.acme.chat.Prompts.verbaliseCard;

@Path("/chat")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public class ChatResource {

    @Inject
    OllamaClient llm;

    @Inject
    SqlRunner sqlRunner;

    @Inject
    ObjectMapper mapper;

    @POST
    @Transactional(Transactional.TxType.REQUIRED) // read-only work fits in a tx for consistency
    public Response chat(ChatRequest req) {
        if (req == null || req.question == null || req.question.isBlank()) {
            throw new BadRequestException("question is required");
        }

        try {
            // Step 1: get plan (sql or final)
            String planJson = llm.chat(schemaCard(), req.question.trim());

            LlmPlan plan = mapper.readValue(planJson, LlmPlan.class);
            if (plan.type == null) throw new WebApplicationException("Model returned an invalid plan", 502);

            if ("final".equalsIgnoreCase(plan.type)) {
                var out = new ChatResponse();
                out.answer = plan.answer == null ? "(no answer)" : plan.answer;
                out.usedSql = false;
                return Response.ok(out).build();
            }

            if (!"sql".equalsIgnoreCase(plan.type) || plan.sql == null || plan.sql.isBlank()) {
                throw new WebApplicationException("Model did not return a SQL plan", 502);
            }

            // Guardrails and run
            sqlRunner.validateReadOnly(plan.sql);
            String safeSql = sqlRunner.enforceLimit(plan.sql);
            var rows = sqlRunner.runNative(safeSql);

            // Step 2: verbalise results
            String verbaliseUserMsg = "Question: " + req.question.trim() + "\n"
                    + "Columns: " + mapper.writeValueAsString(rows.columns) + "\n"
                    + "Rows: " + mapper.writeValueAsString(rows.rows);

            String finalJson = llm.chat(verbaliseCard(), verbaliseUserMsg);
            LlmPlan finalPlan = mapper.readValue(finalJson, LlmPlan.class);
            if (!"final".equalsIgnoreCase(finalPlan.type)) {
                throw new WebApplicationException("Model did not return a final answer", 502);
            }

            var out = new ChatResponse();
            out.answer = finalPlan.answer;
            out.usedSql = true;
            out.sql = safeSql;
            out.rows = rows;
            return Response.ok(out).build();

        } catch (Exception e) {
            var out = new ChatResponse();
            out.error = e.getMessage();
            return Response.status(Response.Status.BAD_GATEWAY).entity(out).build();
        }
    }
}

=====org/acme/chat/Prompts.java=====


package org.acme.chat;

public class Prompts {

    public static String schemaCard() {
        return String.join("\n",
                "You are a helpful data assistant for a football transfer app.",
                "You can only produce JSON with this schema: {\"type\":\"sql\",\"sql\":\"...\"} OR {\"type\":\"final\",\"answer\":\"...\"}.",
                "Never include any extra text outside JSON.",
                "",
                "Database schema (H2):",
                "Table Club columns: id BIGINT, name VARCHAR, budget DECIMAL(19,2)",
                "Table Player columns: id BIGINT, name VARCHAR, price DECIMAL(19,2), club_id BIGINT",
                "Join rule: Player.club_id = Club.id",
                "",
                "Rules:",
                "- Only produce read-only SELECT queries. Never modify data.",
                "- Prefer case-insensitive name matching using UPPER(name) LIKE UPPER('%TERM%').",
                "- If the user asks for counts, use COUNT(*).",
                "- Use simple SQL that H2 supports.",
                "- Keep queries small; avoid selecting too many columns when not needed.",
                "- If the user question is already directly answerable without SQL, return {\"type\":\"final\",\"answer\":\"...\"}.",
                "- Otherwise return {\"type\":\"sql\",\"sql\":\"...\"}.",
                ""
        );
    }

    public static String verbaliseCard() {
        return String.join("\n",
                "You are turning SQL result rows into a single concise natural-language answer.",
                "Only produce JSON with {\"type\":\"final\",\"answer\":\"...\"}. No extra text.",
                "If there are no rows, say that nothing was found.",
                "If the question was for a list, join items with commas in a single sentence."
        );
    }
}

=====org/acme/chat/SqlRunner.java=====


package org.acme.chat;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Pattern;

import static org.acme.chat.ChatDtos.SqlResultForLlm;

@ApplicationScoped
public class SqlRunner {

    @PersistenceContext
    EntityManager em;

    @Inject
    ObjectMapper mapper;

    // Allowed tables and columns (keep small and explicit)
    static final List<String> ALLOWED_TABLES = List.of("CLUB", "PLAYER"); // H2 folds unquoted to upper
    static final List<String> CLUB_COLUMNS = List.of("ID", "NAME", "BUDGET");
    static final List<String> PLAYER_COLUMNS = List.of("ID", "NAME", "PRICE", "CLUB_ID");

    // Very simple checks for learning purposes
    static final Pattern SELECT_ONLY = Pattern.compile("^\\s*SELECT\\b", Pattern.CASE_INSENSITIVE);

    public String enforceLimit(String sql) {
        var up = sql.toUpperCase(Locale.ROOT);
        if (!up.contains("LIMIT ")) {
            return sql.trim() + " LIMIT 200";
        }
        return sql;
    }

    public void validateReadOnly(String sql) {
        if (!SELECT_ONLY.matcher(sql).find()) {
            throw new IllegalArgumentException("Only SELECT queries are allowed");
        }

        // Crude table/column allow-listing by scanning tokens
        var up = sql.toUpperCase(Locale.ROOT);
        // Tables
        for (String token : List.of(" CLUB ", " CLUB)", " CLUB,", " CLUB\n", " CLUB\t",
                " PLAYER ", " PLAYER)", " PLAYER,", " PLAYER\n", " PLAYER\t")) {
            // presence is OK, but we also ensure no unknown table is referenced by FROM/JOIN
        }
        // A stricter approach: forbid quotes and semicolons for this exercise
        if (up.contains(";") || up.contains("--") || up.contains("/*")) {
            throw new IllegalArgumentException("Suspicious SQL");
        }
        // Columns: we just prevent obvious unknown identifiers by a tiny heuristic
        // (For a real system, parse SQL or use a safe query builder)
    }

    @SuppressWarnings("unchecked")
    public SqlResultForLlm runNative(String sql) {
        var q = em.createNativeQuery(sql);
        var result = q.getResultList();

        List<String> columns = new ArrayList<>();
        List<List<Object>> rows = new ArrayList<>();

        String up = sql.toUpperCase(Locale.ROOT);
        boolean isClub = up.contains("FROM CLUB");
        boolean isPlayer = up.contains("FROM PLAYER");

        // If result is not empty and first row is Object[], infer columns by count
        if (!result.isEmpty() && result.get(0) instanceof Object[]) {
            int width = ((Object[]) result.get(0)).length;
            if (isClub && width == CLUB_COLUMNS.size()) {
                columns = new ArrayList<>(CLUB_COLUMNS);
            } else if (isPlayer && width == PLAYER_COLUMNS.size()) {
                columns = new ArrayList<>(PLAYER_COLUMNS);
            } else {
                for (int i = 0; i < width; i++) columns.add("col" + (i + 1));
            }
        } else if (!result.isEmpty()) {
            // Single column result
            if (isClub) {
                columns = List.of(CLUB_COLUMNS.get(0));
            } else if (isPlayer) {
                columns = List.of(PLAYER_COLUMNS.get(0));
            } else {
                columns = List.of("col1");
            }
        } else {
            // No results, fallback to table columns if possible
            if (isClub) {
                columns = new ArrayList<>(CLUB_COLUMNS);
            } else if (isPlayer) {
                columns = new ArrayList<>(PLAYER_COLUMNS);
            }
        }

        for (Object row : result) {
            List<Object> rowList = new ArrayList<>();
            if (row instanceof Object[]) {
                Object[] arr = (Object[]) row;
                for (int i = 0; i < columns.size() && i < arr.length; i++) {
                    rowList.add(arr[i]);
                }
            } else if (row instanceof Map) {
                Map<?,?> mapRow = (Map<?,?>) row;
                for (String col : columns) {
                    rowList.add(mapRow.get(col));
                }
            } else {
                // Single column result
                rowList.add(row);
            }
            rows.add(rowList);
        }

        var out = new SqlResultForLlm();
        out.columns = columns;
        out.rows = rows;
        return out;
    }
}

=====org/acme/chat/OllamaClient.java=====


package org.acme.chat;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import org.eclipse.microprofile.config.inject.ConfigProperty;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.List;

import static org.acme.chat.ChatDtos.*;

@ApplicationScoped
public class OllamaClient {

    @ConfigProperty(name = "ollama.base-url", defaultValue = "http://localhost:11434")
    String baseUrl;

    @ConfigProperty(name = "ollama.model", defaultValue = "mistral:latest")
    String model;

    @ConfigProperty(name = "ollama.connect-timeout", defaultValue = "5000")
    int connectTimeoutMs;

    @ConfigProperty(name = "ollama.read-timeout", defaultValue = "30000")
    int readTimeoutMs;

    @Inject
    ObjectMapper mapper;

    HttpClient client;

    void ensureClient() {
        if (client == null) {
            client = HttpClient.newBuilder()
                    .connectTimeout(Duration.ofMillis(connectTimeoutMs))
                    .build();
        }
    }

    public String chat(String systemPrompt, String userPrompt) throws Exception {
        ensureClient();

        var req = new OllamaChatRequest();
        req.model = model;
        req.stream = false;
        req.messages = List.of(
                new OllamaMessage("system", systemPrompt),
                new OllamaMessage("user", userPrompt)
        );

        var body = mapper.writeValueAsString(req);

        var httpReq = HttpRequest.newBuilder()
                .uri(URI.create(baseUrl + "/api/chat"))
                .timeout(Duration.ofMillis(readTimeoutMs))
                .header("Content-Type", "application/json")
                .POST(HttpRequest.BodyPublishers.ofString(body))
                .build();

        var resp = client.send(httpReq, HttpResponse.BodyHandlers.ofString());
        if (resp.statusCode() >= 300) {
            throw new RuntimeException("Ollama error: HTTP " + resp.statusCode() + " body=" + resp.body());
        }

        // Ollama returns: {"message":{"role":"assistant","content":"..."},"done":true,...}
        var node = (ObjectNode) mapper.readTree(resp.body());
        var msg = node.path("message").path("content").asText(null);
        if (msg == null) {
            // Fallback older shapes
            msg = node.path("content").asText(null);
        }
        if (msg == null) {
            throw new RuntimeException("Could not parse Ollama response message");
        }
        return msg;
    }
}

=====org/acme/chat/ChatDtos.java=====


package org.acme.chat;

import java.util.List;
import java.util.Map;

public class ChatDtos {

    public static class ChatRequest {
        public String question;
    }

    public static class ChatResponse {
        public String answer;
        public boolean usedSql;
        public String sql;           // optional, for debugging
        public Object rows;          // optional, echo rows we used
        public String error;         // optional
    }

    // Internal DTOs to talk to Ollama /api/chat
    public static class OllamaMessage {
        public String role;
        public String content;
        public OllamaMessage() {}
        public OllamaMessage(String role, String content) { this.role = role; this.content = content; }
    }

    public static class OllamaChatRequest {
        public String model;
        public List<OllamaMessage> messages;
        public boolean stream = false;
        public Map<String,Object> options; // optional tuning
    }

    public static class OllamaChatResponse {
        public String model;
        public String created_at;
        public List<Choice> message; // NOTE: Ollama returns a single message object in newer APIs; weâ€™ll parse content safely
        public String done_reason;
        public boolean done;
        // We only need the assistant message content; to be robust, we'll map a minimal structure:
        public AssistantMessage messageObj;
        public static class Choice { public String content; }
        public static class AssistantMessage { public String role; public String content; }
    }

    // The strict JSON the model should return to us
    public static class LlmPlan {
        public String type;  // "sql" or "final"
        public String sql;
        public String answer;
    }

    public static class SqlResultForLlm {
        public List<String> columns;
        public List<List<Object>> rows;
    }
}

=====org/acme/chat/SqlResource.java=====


package org.acme.chat;

import jakarta.inject.Inject;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import io.smallrye.common.annotation.Blocking;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;

@Path("/sql")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public class SqlResource {

    @Inject
    SqlRunner sqlRunner;

    @POST
    @Blocking // Ensure DB access is on a worker thread
    public Response runSql(Map<String, String> body) {
        String sql = body.get("sql");
        if (sql == null || sql.isBlank()) {
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(Map.of("error", "Missing 'sql' field in request body"))
                    .build();
        }
        try {
            // Validate and enforce limit
            sqlRunner.validateReadOnly(sql);
            String safeSql = sqlRunner.enforceLimit(sql);
            // Run the query
            var result = sqlRunner.runNative(safeSql);
            // Convert columns and rows to a list of maps
            List<Map<String, Object>> rows = new ArrayList<>();
            for (List<Object> row : result.rows) {
                Map<String, Object> rowMap = new java.util.LinkedHashMap<>();
                for (int i = 0; i < result.columns.size(); i++) {
                    rowMap.put(result.columns.get(i), row.get(i));
                }
                rows.add(rowMap);
            }
            return Response.ok(Map.of("rows", rows)).build();
        } catch (IllegalArgumentException e) {
            // For validation errors (e.g., non-SELECT statement)
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(Map.of("error", e.getMessage()))
                    .build();
        } catch (Exception e) {
            // For all other errors
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                    .entity(Map.of("error", e.getMessage()))
                    .build();
        }
    }
}


=====org/acme/ClubResource.java=====


package org.acme;

import org.acme.dto.CreateClubRequest;
import io.smallrye.common.annotation.Blocking;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

@Path("/clubs")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Blocking
public class ClubResource {

    @GET
    public List<Club> list() {
        return Club.listAll();
    }

    @GET
    @Path("/{id}")
    public Club get(@PathParam("id") Long id) {
        return Club.<Club>findByIdOptional(id)
                .orElseThrow(() -> new NotFoundException("Club not found: " + id));
    }

    @POST
    @Transactional
    public Response create(CreateClubRequest req) {
        if (req == null || req.name == null || req.name.isBlank())
            throw new BadRequestException("name is required");
        if (req.budget == null || req.budget.compareTo(BigDecimal.ZERO) < 0)
            throw new BadRequestException("budget must be >= 0");

        Club c = new Club();
        c.name = req.name.trim();
        c.budget = req.budget;
        c.persist();

        return Response
                .status(Response.Status.CREATED)
                .entity(c)
                .build();
    }
}

=====org/acme/PlayerResource.java=====


package org.acme;

import org.acme.dto.CreatePlayerRequest;
import io.smallrye.common.annotation.Blocking;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import java.math.BigDecimal;
import java.util.List;

@Path("/players")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Blocking
public class PlayerResource {

    @GET
    public List<Player> list() {
        return Player.listAll();
    }

    @GET
    @Path("/{id}")
    public Player get(@PathParam("id") Long id) {
        return Player.<Player>findByIdOptional(id)
                .orElseThrow(() -> new NotFoundException("Player not found: " + id));
    }

    @POST
    @Transactional
    public Response create(CreatePlayerRequest req) {
        if (req == null || req.name == null || req.name.isBlank())
            throw new BadRequestException("name is required");
        if (req.price == null || req.price.compareTo(BigDecimal.ZERO) < 0)
            throw new BadRequestException("price must be >= 0");
        if (req.clubId == null)
            throw new BadRequestException("clubId is required");

        Club club = Club.<Club>findByIdOptional(req.clubId)
                .orElseThrow(() -> new NotFoundException("clubId not found: " + req.clubId));

        Player p = new Player();
        p.name = req.name.trim();
        p.price = req.price;
        p.club = club;
        p.persist();

        return Response.status(Response.Status.CREATED).entity(p).build();
    }
}

=====org/acme/TransferService.java=====


package org.acme;

import org.acme.dto.TransferResult;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.BadRequestException;
import jakarta.ws.rs.NotFoundException;
import java.math.BigDecimal;

@ApplicationScoped
public class TransferService {

    @Transactional
    public TransferResult transfer(Long buyerClubId, Long playerId) {
        if (buyerClubId == null || playerId == null)
            throw new BadRequestException("buyerClubId and playerId are required");

        Club buyer = Club.<Club>findByIdOptional(buyerClubId)
                .orElseThrow(() -> new NotFoundException("Buyer club not found: " + buyerClubId));

        Player player = Player.<Player>findByIdOptional(playerId)
                .orElseThrow(() -> new NotFoundException("Player not found: " + playerId));

        Club seller = player.club;
        if (seller == null)
            throw new BadRequestException("Player has no current club");
        if (seller.id.equals(buyer.id))
            throw new BadRequestException("Buyer already owns this player");

        BigDecimal price = player.price;
        if (buyer.budget.compareTo(price) < 0)
            throw new BadRequestException("Buyer cannot afford this player");

        // Money moves: buyer pays, seller receives
        buyer.budget = buyer.budget.subtract(price);
        seller.budget = seller.budget.add(price);

        // Transfer registration
        player.club = buyer;


        // result payload
        TransferResult result = new TransferResult();
        result.playerId = player.id;
        result.playerName = player.name;
        result.fromClub = seller.name;
        result.toClub = buyer.name;
        result.price = price;
        result.buyerBudgetAfter = buyer.budget;
        result.sellerBudgetAfter = seller.budget;

        return result;
    }
}

=====org/acme/GreetingResource.java=====


package org.acme;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/hello")
public class GreetingResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "Hello from Quarkus REST";
    }
}


=====org/acme/Player.java=====


package org.acme;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.quarkus.hibernate.orm.panache.PanacheEntity;
import jakarta.persistence.*;
import java.math.BigDecimal;

@Entity
public class Player extends PanacheEntity {

    @Column(nullable = false)
    public String name;

    @Column(nullable = false, precision = 19, scale = 2)
    public BigDecimal price;

    @ManyToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = "club_id")
    @JsonIgnore
    public Club club;

    @JsonProperty("clubId")
    public Long jsonClubId() {
        return club == null ? null : club.id;
    }
}

=====org/acme/TransferResource.java=====


package org.acme;

import org.acme.dto.TransferRequest;                 // input DTO
import org.acme.dto.TransferResult;                  // output DTO
import io.smallrye.common.annotation.Blocking;                   // JPA is blocking
import jakarta.inject.Inject;                                    // DI for service
import jakarta.ws.rs.*;                                          // JAX-RS annotations
import jakarta.ws.rs.core.MediaType;                             // JSON
import jakarta.ws.rs.core.Response;                              // HTTP responses

@Path("/transfers")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Blocking
public class TransferResource {

    @Inject
    TransferService service;

    @POST
    public Response transfer(TransferRequest req) {
        TransferResult result = service.transfer(req.buyerClubId, req.playerId);
        return Response.ok(result).build();
    }
}

=====org/acme/Club.java=====


package org.acme;

import io.quarkus.hibernate.orm.panache.PanacheEntity;
import jakarta.persistence.*;
import java.math.BigDecimal;
import java.util.List;

@Entity
public class Club extends PanacheEntity {

    @Column(nullable = false, unique = true)
    public String name;

    @Column(nullable = false, precision = 19, scale = 2)
    public BigDecimal budget;

    @OneToMany(mappedBy = "club",
            cascade = CascadeType.ALL,
            orphanRemoval = true)
    public List<Player> players;
}

=====org/acme/GenericExceptionMapper.java=====


package org.acme;

import jakarta.ws.rs.ext.ExceptionMapper;
import jakarta.ws.rs.ext.Provider;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.NotFoundException;
import jakarta.ws.rs.BadRequestException;
import java.util.HashMap;
import java.util.Map;

@Provider
public class GenericExceptionMapper implements ExceptionMapper<Throwable> {
    @Override
    public Response toResponse(Throwable exception) {
        Map<String, String> error = new HashMap<>();
        error.put("error", exception.getMessage());

        if (exception instanceof NotFoundException) {
            return Response.status(Response.Status.NOT_FOUND)
                    .entity(error)
                    .type(MediaType.APPLICATION_JSON)
                    .build();
        } else if (exception instanceof BadRequestException) {
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(error)
                    .type(MediaType.APPLICATION_JSON)
                    .build();
        } else {
            // For all other exceptions, return 500
            error.put("error", "Internal server error");
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                    .entity(error)
                    .type(MediaType.APPLICATION_JSON)
                    .build();
        }
    }
}

====resources/application.properties====

# CORS (current key)
quarkus.http.cors.enabled=true

# H2 datasource
quarkus.datasource.db-kind=h2
quarkus.datasource.jdbc.url=jdbc:h2:mem:transferdb;DB_CLOSE_DELAY=-1
quarkus.datasource.username=sa
quarkus.datasource.password=sa

# DDL (use the key your version recognizes)
quarkus.hibernate-orm.database.generation=drop-and-create

# Logging keys
quarkus.hibernate-orm.log.sql=true
quarkus.hibernate-orm.log.format-sql=true

# Seed in dev/main only (tests override it to 'no-file')
quarkus.hibernate-orm.sql-load-script=import.sql

# Ollama
ollama.base-url=http://localhost:11434
ollama.model=mistral:latest

# Optional: timeouts (ms)
ollama.connect-timeout=5000
ollama.read-timeout=30000

====resources/import.sql====

-- Clubs
INSERT INTO Club(id, name, budget) VALUES (1, 'Arandale FC', 100000000.00);
INSERT INTO Club(id, name, budget) VALUES (2, 'Bristol Rovers 2.0', 45000000.00);
INSERT INTO Club(id, name, budget) VALUES (3, 'Manchester United', 200000000.00);
INSERT INTO Club(id, name, budget) VALUES (4, 'Chelsea FC', 180000000.00);
INSERT INTO Club(id, name, budget) VALUES (5, 'FC Barcelona', 220000000.00);

ALTER SEQUENCE Club_SEQ RESTART WITH 6;

-- Players
INSERT INTO Player(id, name, price, club_id) VALUES (1, 'Luis Bento', 30000000.00, 1);
INSERT INTO Player(id, name, price, club_id) VALUES (2, 'Marco Silva', 60000000.00, 1);
INSERT INTO Player(id, name, price, club_id) VALUES (3, 'Cristiano Ronaldo', 90000000.00, 3);
INSERT INTO Player(id, name, price, club_id) VALUES (4, 'Marcus Rashford', 70000000.00, 3);
INSERT INTO Player(id, name, price, club_id) VALUES (5, 'Mason Mount', 60000000.00, 4);
INSERT INTO Player(id, name, price, club_id) VALUES (6, 'Raheem Sterling', 65000000.00, 4);
INSERT INTO Player(id, name, price, club_id) VALUES (7, 'Robert Lewandowski', 85000000.00, 5);
INSERT INTO Player(id, name, price, club_id) VALUES (8, 'Pedri', 75000000.00, 5);


